#!/usr/bin/env bash
set -u
exec </dev/tty

echo "[pre-push] Go checks"

# --- config knobs (env overridable) -----------------------------------------
: "${GITHOOKS_SKIP_LINT:=0}"
: "${GITHOOKS_SKIP_VULN:=0}"
: "${GITHOOKS_VULN_MODE:=imports}"   # imports | source (source is slower)
: "${GITHOOKS_SKIP_TESTS:=0}"
: "${GITHOOKS_TEST_RACE:=1}"
: "${GITHOOKS_TEST_P:=4}"
: "${GITHOOKS_FAILFAST:=1}"
# -----------------------------------------------------------------------------

# Read first pre-push line: local_ref local_sha remote_ref remote_sha
read -r LOCAL_REF LOCAL_SHA REMOTE_REF REMOTE_SHA || true

ZERO40="0000000000000000000000000000000000000000"
if [[ -n "${REMOTE_SHA:-}" && "$REMOTE_SHA" != "$ZERO40" ]]; then
  BASE_SHA="$REMOTE_SHA"
else
  DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || true)
  if [[ -n "$DEFAULT_BRANCH" ]]; then
    BASE_SHA=$(git rev-parse "$DEFAULT_BRANCH" 2>/dev/null || true)
  fi
  BASE_SHA="${BASE_SHA:-$(git rev-parse HEAD~1 2>/dev/null || echo "$ZERO40")}"
fi
RANGE="${BASE_SHA}..HEAD"

# Fast exit if no Go changes
CHANGED_GO=$(git diff --name-only "$RANGE" -- '*.go' 2>/dev/null || true)
if [[ -z "$CHANGED_GO" ]]; then
  echo "[pre-push] No Go changes in $RANGE — skipping."
  exit 0
fi

# Map changed files -> unique import paths
mapfile -t PKG_DIRS < <(printf "%s\n" "$CHANGED_GO" | xargs -r -n1 dirname | sort -u)
mapfile -t PKGS < <(printf "%s\n" "${PKG_DIRS[@]}" | xargs -r -n50 go list 2>/dev/null | sort -u)
if [[ ${#PKGS[@]} -eq 0 ]] || ! go list ./... >/dev/null 2>&1; then
  echo "[pre-push] No importable Go packages or not a module/workspace — skipping."
  exit 0
fi

# ----------------------- LINT ------------------------------------------------
if [[ "$GITHOOKS_SKIP_LINT" != "1" ]]; then
  if ! command -v golangci-lint >/dev/null 2>&1; then
    echo "golangci-lint not installed or not in PATH" >&2
    echo "See: https://github.com/golangci/golangci-lint" >&2
    exit 1
  fi
  echo "[pre-push] golangci-lint ($RANGE)…"
  if [[ "$BASE_SHA" != "$ZERO40" ]]; then
    golangci-lint run --new-from-rev="$BASE_SHA" -n
  else
    golangci-lint run --new-from-rev=HEAD~1 -n
  fi
  LINT_RC=$?
  if [[ $LINT_RC -ne 0 ]]; then
    while read -r -p "golangci-lint found issues. Continue anyway? (y/n) " yn; do
      case $yn in [Yy]) echo "Continuing despite linter issues…"; break ;;
                   [Nn]) exit 1 ;;
                   *) echo "Please answer y or n." ;; esac
    done
  fi
fi

# ----------------------- VULN (govulncheck) ---------------------------------
if [[ "$GITHOOKS_SKIP_VULN" != "1" ]]; then
  if ! command -v govulncheck >/dev/null 2>&1; then
    echo "govulncheck not installed or not in PATH" >&2
    echo "Install: go install golang.org/x/vuln/cmd/govulncheck@latest" >&2
    exit 1
  fi
  echo "[pre-push] govulncheck (${GITHOOKS_VULN_MODE}) on changed packages…"
  # Faster: restrict to changed packages; use JSON to detect findings robustly
  # govulncheck exits 0 even when findings exist, so we parse output.
  OUT_JSON="$(mktemp)"
  if ! govulncheck -json -mode="${GITHOOKS_VULN_MODE}" "${PKGS[@]}" >"$OUT_JSON" 2>/dev/null; then
    echo "govulncheck failed to run (tool error)."
    rm -f "$OUT_JSON"
    exit 1
  fi

  # Any "finding" objects?
  if grep -q '"finding"' "$OUT_JSON"; then
    echo
    echo "⚠️  govulncheck reported vulnerabilities that may affect your code."
    # Show a concise summary (IDs and package)
    awk '
      /"finding"/ {inFinding=1}
      inFinding && /"symbol":/ {gsub(/[",]/,""); sym=$2}
      inFinding && /"package":/ {gsub(/[",]/,""); pkg=$2}
      inFinding && /"id":/ {gsub(/[",]/,""); id=$2}
      inFinding && /}/ { if (id!="") { printf(" - %s in %s (%s)\n", id, pkg, sym); id=""; pkg=""; sym="" } inFinding=0}
    ' "$OUT_JSON" | sort -u
    echo
    while read -r -p "Continue push anyway? (y/n) " yn; do
      case $yn in [Yy]) echo "Continuing despite vulnerabilities…"; break ;;
                   [Nn]) rm -f "$OUT_JSON"; exit 1 ;;
                   *) echo "Please answer y or n." ;; esac
    done
  fi
  rm -f "$OUT_JSON"
fi

# ----------------------- TEST ------------------------------------------------
if [[ "$GITHOOKS_SKIP_TESTS" != "1" ]]; then
  echo "[pre-push] go test on changed packages…"
  TEST_CMD="go test"; command -v gotest >/dev/null 2>&1 && TEST_CMD="gotest"
  ARGS=(-count=1 -p "$GITHOOKS_TEST_P")
  [[ "$GITHOOKS_FAILFAST" == "1" ]] && ARGS+=(-failfast)
  [[ "$GITHOOKS_TEST_RACE" == "1" ]] && ARGS+=(-race)

  printf "%s\n" "${PKGS[@]}" | xargs -r -n1 -P "$GITHOOKS_TEST_P" bash -c '
    pkg="$1"; shift
    if ! '"$TEST_CMD"' "${@}" "$pkg" >/dev/null; then
      echo "[FAIL] '"$TEST_CMD"' ${*} $pkg"
      exit 1
    fi
  ' _ "${ARGS[@]}"
  TEST_RC=$?

  if [[ $TEST_RC -ne 0 ]]; then
    while read -r -p "Tests failed. Continue push anyway? (y/n) " yn; do
      case $yn in [Yy]) echo "Continuing despite test failures…"; break ;;
                   [Nn]) exit 1 ;;
                   *) echo "Please answer y or n." ;; esac
    done
  fi
fi

echo "[pre-push] OK"
exit 0
